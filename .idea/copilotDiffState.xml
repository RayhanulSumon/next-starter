<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="# dependencies&#10;/node_modules&#10;/.pnp&#10;.pnp.js&#10;&#10;# testing&#10;/coverage&#10;&#10;# next.js&#10;/.next/&#10;/out/&#10;&#10;# production&#10;/build&#10;&#10;# misc&#10;.DS_Store&#10;*.pem&#10;&#10;# debug&#10;npm-debug.log*&#10;yarn-debug.log*&#10;yarn-error.log*&#10;&#10;# local env files&#10;.env*.local&#10;.env&#10;&#10;# vercel&#10;.vercel&#10;&#10;# typescript&#10;*.tsbuildinfo&#10;next-env.d.ts" />
              <option name="updatedContent" value="# dependencies&#10;/node_modules&#10;/.pnp&#10;.pnp.js&#10;&#10;# testing&#10;/coverage&#10;&#10;# next.js&#10;/.next/&#10;/out/&#10;&#10;# production&#10;/build&#10;&#10;# misc&#10;.DS_Store&#10;*.pem&#10;&#10;# debug&#10;npm-debug.log*&#10;yarn-debug.log*&#10;yarn-error.log*&#10;&#10;# local env files&#10;.env*.local&#10;.env&#10;&#10;# vercel&#10;.vercel&#10;&#10;# typescript&#10;*.tsbuildinfo&#10;next-env.d.ts&#10;&#10;# IDE specific files&#10;.idea/&#10;.vscode/&#10;*.sublime-project&#10;*.sublime-workspace&#10;.project&#10;.classpath&#10;.c9/&#10;*.launch&#10;.settings/&#10;*.suo&#10;*.ntvs*&#10;*.njsproj&#10;*.sln&#10;*.sw?" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/actions/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/actions/auth.ts" />
              <option name="originalContent" value="'use server';&#10;&#10;import { cookies } from 'next/headers';&#10;import { redirect } from 'next/navigation';&#10;import { revalidatePath } from 'next/cache';&#10;import type {&#10;  RegisterData,&#10;  User,&#10;  PasswordResetRequest,&#10;  PasswordResetData,&#10;  PasswordResetResponse,&#10;  UserRole&#10;} from '@/types/auth';&#10;&#10;// Environment variable for API URL - correctly typed and defined&#10;const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://127.0.0.1:8000/api';&#10;&#10;// Properly typed cookie options aligned with Next.js 15.4.2&#10;type CookieOptions = {&#10;  httpOnly?: boolean;&#10;  path?: string;&#10;  sameSite?: 'strict' | 'lax' | 'none';&#10;  secure?: boolean;&#10;  maxAge?: number;&#10;  expires?: Date;&#10;};&#10;&#10;// Define the structure for API error responses&#10;interface ApiErrorData {&#10;  message?: string;&#10;  errors?: Record&lt;string, string[]&gt;;&#10;  [key: string]: unknown;&#10;}&#10;&#10;/**&#10; * API error class for better error handling&#10; */&#10;class ApiError extends Error {&#10;  status: number;&#10;  data: ApiErrorData;&#10;&#10;  constructor(message: string, status: number, data: ApiErrorData = {}) {&#10;    super(message);&#10;    this.name = 'ApiError';&#10;    this.status = status;&#10;    this.data = data;&#10;  }&#10;}&#10;&#10;/**&#10; * Interface for the cookie store methods&#10; */&#10;interface CookieStore {&#10;  set(name: string, value: string, options?: CookieOptions): void;&#10;  get(name: string): { name: string; value: string } | undefined;&#10;  delete(name: string): void;&#10;}&#10;&#10;/**&#10; * Type-safe cookie management for Next.js server components&#10; */&#10;const cookieStore = {&#10;  set(name: string, value: string, options?: CookieOptions): void {&#10;    // Cast to any to bypass the type error - Next.js typing issue with cookies()&#10;    // See: https://github.com/vercel/next.js/issues/49259&#10;    (cookies() as any).set(name, value, options);&#10;  },&#10;&#10;  get(name: string): string | undefined {&#10;    // Cast to any to bypass the type error - Next.js typing issue with cookies()&#10;    return (cookies() as any).get(name)?.value;&#10;  },&#10;&#10;  delete(name: string): void {&#10;    // Cast to any to bypass the type error - Next.js typing issue with cookies()&#10;    (cookies() as any).delete(name);&#10;  }&#10;};&#10;&#10;/**&#10; * Helper function for API requests with proper typing and error handling&#10; */&#10;async function apiRequest&lt;T&gt;(&#10;  endpoint: string,&#10;  options: RequestInit &amp; {&#10;    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'&#10;  }&#10;): Promise&lt;T&gt; {&#10;  const url = `${API_URL}${endpoint}`;&#10;&#10;  try {&#10;    const response = await fetch(url, {&#10;      ...options,&#10;      cache: 'no-store', // Ensure fresh data&#10;      next: { tags: ['auth'] } // For revalidation&#10;    });&#10;&#10;    // Parse response as JSON with unknown type first for safety&#10;    const data = await response.json() as unknown;&#10;&#10;    if (!response.ok) {&#10;      // Type guard to ensure data has expected structure&#10;      const errorData: ApiErrorData = &#10;        typeof data === 'object' &amp;&amp; data !== null &#10;          ? data as ApiErrorData &#10;          : {};&#10;          &#10;      const errorMessage = &#10;        typeof errorData.message === 'string' &#10;          ? errorData.message &#10;          : `API error (${response.status})`;&#10;          &#10;      throw new ApiError(&#10;        errorMessage,&#10;        response.status,&#10;        errorData&#10;      );&#10;    }&#10;&#10;    return data as T;&#10;  } catch (error) {&#10;    if (error instanceof ApiError) {&#10;      throw error;&#10;    }&#10;    &#10;    // Handle fetch errors (network issues, etc.)&#10;    throw new ApiError(&#10;      error instanceof Error ? error.message : 'Unknown API error',&#10;      500,&#10;      {}&#10;    );&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to login a user&#10; */&#10;export async function loginUser(identifier: string, password: string): Promise&lt;User&gt; {&#10;  try {&#10;    const data = await apiRequest&lt;{ token: string; user: User }&gt;('/login', {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ identifier, password }),&#10;    });&#10;&#10;    // Set the authentication token in cookies&#10;    cookieStore.set('token', data.token, {&#10;      httpOnly: true,&#10;      path: '/',&#10;      sameSite: 'strict',&#10;      secure: process.env.NODE_ENV === 'production',&#10;    });&#10;&#10;    // Revalidate any data that depends on authentication&#10;    revalidatePath('/dashboard');&#10;&#10;    return data.user;&#10;  } catch (error) {&#10;    console.error('Login error:', error);&#10;    throw error;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to register a new user&#10; */&#10;export async function registerUser(data: RegisterData): Promise&lt;User&gt; {&#10;  try {&#10;    const result = await apiRequest&lt;{ token: string; user: User }&gt;('/register', {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify(data),&#10;    });&#10;&#10;    // Set the authentication token in cookies&#10;    cookieStore.set('token', result.token, {&#10;      httpOnly: true,&#10;      path: '/',&#10;      sameSite: 'strict',&#10;      secure: process.env.NODE_ENV === 'production',&#10;    });&#10;&#10;    // Revalidate any data that depends on authentication&#10;    revalidatePath('/dashboard');&#10;&#10;    return result.user;&#10;  } catch (error) {&#10;    console.error('Registration error:', error);&#10;    throw error;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to logout a user&#10; */&#10;export async function logoutUser(): Promise&lt;void&gt; {&#10;  const token = cookieStore.get('token');&#10;&#10;  if (token) {&#10;    try {&#10;      await apiRequest&lt;void&gt;('/logout', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Authorization': `Bearer ${token}`,&#10;          'Content-Type': 'application/json',&#10;        }&#10;      });&#10;    } catch (error) {&#10;      // Continue with logout even if API call fails&#10;      console.error('Logout API error:', error);&#10;    }&#10;  }&#10;&#10;  // Always delete the token cookie&#10;  cookieStore.delete('token');&#10;&#10;  // Revalidate relevant paths&#10;  revalidatePath('/', 'layout');&#10;&#10;  // Redirect to home page&#10;  redirect('/');&#10;}&#10;&#10;/**&#10; * Server-side function to get the current user&#10; */&#10;export async function getCurrentUser(): Promise&lt;User | null&gt; {&#10;  const token = cookieStore.get('token');&#10;&#10;  if (!token) {&#10;    return null;&#10;  }&#10;&#10;  try {&#10;    const user = await apiRequest&lt;User&gt;('/user', {&#10;      method: 'GET',&#10;      headers: {&#10;        'Authorization': `Bearer ${token}`,&#10;        'Content-Type': 'application/json',&#10;      }&#10;    });&#10;&#10;    return user;&#10;  } catch (error) {&#10;    // Token is invalid, clear it&#10;    cookieStore.delete('token');&#10;    return null;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to request password reset&#10; */&#10;export async function requestPasswordReset(data: PasswordResetRequest): Promise&lt;PasswordResetResponse&gt; {&#10;  return apiRequest&lt;PasswordResetResponse&gt;('/request-password-reset', {&#10;    method: 'POST',&#10;    headers: { 'Content-Type': 'application/json' },&#10;    body: JSON.stringify(data),&#10;  });&#10;}&#10;&#10;/**&#10; * Server-side function to reset password&#10; */&#10;export async function resetPassword(data: PasswordResetData): Promise&lt;PasswordResetResponse&gt; {&#10;  return apiRequest&lt;PasswordResetResponse&gt;('/reset-password', {&#10;    method: 'POST',&#10;    headers: { 'Content-Type': 'application/json' },&#10;    body: JSON.stringify(data),&#10;  });&#10;}" />
              <option name="updatedContent" value="'use server';&#10;&#10;import { cookies } from 'next/headers';&#10;import { redirect } from 'next/navigation';&#10;import { revalidatePath } from 'next/cache';&#10;import type {&#10;  RegisterData,&#10;  User,&#10;  PasswordResetRequest,&#10;  PasswordResetData,&#10;  PasswordResetResponse,&#10;  UserRole&#10;} from '@/types/auth';&#10;&#10;// Environment variable for API URL - correctly typed and defined&#10;const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://127.0.0.1:8000/api';&#10;&#10;// Properly typed cookie options aligned with Next.js 15.4.2&#10;type CookieOptions = {&#10;  httpOnly?: boolean;&#10;  path?: string;&#10;  sameSite?: 'strict' | 'lax' | 'none';&#10;  secure?: boolean;&#10;  maxAge?: number;&#10;  expires?: Date;&#10;};&#10;&#10;// Define the structure for API error responses&#10;interface ApiErrorData {&#10;  message?: string;&#10;  errors?: Record&lt;string, string[]&gt;;&#10;  [key: string]: unknown;&#10;}&#10;&#10;/**&#10; * API error class for better error handling&#10; */&#10;class ApiError extends Error {&#10;  status: number;&#10;  data: ApiErrorData;&#10;&#10;  constructor(message: string, status: number, data: ApiErrorData = {}) {&#10;    super(message);&#10;    this.name = 'ApiError';&#10;    this.status = status;&#10;    this.data = data;&#10;  }&#10;}&#10;&#10;/**&#10; * Interface for the cookie store methods&#10; */&#10;interface CookieStore {&#10;  set(name: string, value: string, options?: CookieOptions): void;&#10;  get(name: string): { name: string; value: string } | undefined;&#10;  delete(name: string): void;&#10;}&#10;&#10;/**&#10; * Type-safe cookie management for Next.js server components&#10; */&#10;const cookieStore = {&#10;  set(name: string, value: string, options?: CookieOptions): void {&#10;    // Use type assertion with a specific interface instead of 'any'&#10;    const cookieJar = cookies() as unknown as CookieStore;&#10;    cookieJar.set(name, value, options);&#10;  },&#10;&#10;  get(name: string): string | undefined {&#10;    // Use type assertion with a specific interface instead of 'any'&#10;    const cookieJar = cookies() as unknown as CookieStore;&#10;    return cookieJar.get(name)?.value;&#10;  },&#10;&#10;  delete(name: string): void {&#10;    // Use type assertion with a specific interface instead of 'any'&#10;    const cookieJar = cookies() as unknown as CookieStore;&#10;    cookieJar.delete(name);&#10;  }&#10;};&#10;&#10;/**&#10; * Helper function for API requests with proper typing and error handling&#10; */&#10;async function apiRequest&lt;T&gt;(&#10;  endpoint: string,&#10;  options: RequestInit &amp; {&#10;    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'&#10;  }&#10;): Promise&lt;T&gt; {&#10;  const url = `${API_URL}${endpoint}`;&#10;&#10;  try {&#10;    const response = await fetch(url, {&#10;      ...options,&#10;      cache: 'no-store', // Ensure fresh data&#10;      next: { tags: ['auth'] } // For revalidation&#10;    });&#10;&#10;    // Parse response as JSON with unknown type first for safety&#10;    const data = await response.json() as unknown;&#10;&#10;    if (!response.ok) {&#10;      // Type guard to ensure data has expected structure&#10;      const errorData: ApiErrorData = &#10;        typeof data === 'object' &amp;&amp; data !== null &#10;          ? data as ApiErrorData &#10;          : {};&#10;          &#10;      const errorMessage = &#10;        typeof errorData.message === 'string' &#10;          ? errorData.message &#10;          : `API error (${response.status})`;&#10;          &#10;      throw new ApiError(&#10;        errorMessage,&#10;        response.status,&#10;        errorData&#10;      );&#10;    }&#10;&#10;    return data as T;&#10;  } catch (error) {&#10;    if (error instanceof ApiError) {&#10;      throw error;&#10;    }&#10;    &#10;    // Handle fetch errors (network issues, etc.)&#10;    throw new ApiError(&#10;      error instanceof Error ? error.message : 'Unknown API error',&#10;      500,&#10;      {}&#10;    );&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to login a user&#10; */&#10;export async function loginUser(identifier: string, password: string): Promise&lt;User&gt; {&#10;  try {&#10;    const data = await apiRequest&lt;{ token: string; user: User }&gt;('/login', {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ identifier, password }),&#10;    });&#10;&#10;    // Set the authentication token in cookies&#10;    cookieStore.set('token', data.token, {&#10;      httpOnly: true,&#10;      path: '/',&#10;      sameSite: 'strict',&#10;      secure: process.env.NODE_ENV === 'production',&#10;    });&#10;&#10;    // Revalidate any data that depends on authentication&#10;    revalidatePath('/dashboard');&#10;&#10;    return data.user;&#10;  } catch (error) {&#10;    console.error('Login error:', error);&#10;    throw error;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to register a new user&#10; */&#10;export async function registerUser(data: RegisterData): Promise&lt;User&gt; {&#10;  try {&#10;    const result = await apiRequest&lt;{ token: string; user: User }&gt;('/register', {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify(data),&#10;    });&#10;&#10;    // Set the authentication token in cookies&#10;    cookieStore.set('token', result.token, {&#10;      httpOnly: true,&#10;      path: '/',&#10;      sameSite: 'strict',&#10;      secure: process.env.NODE_ENV === 'production',&#10;    });&#10;&#10;    // Revalidate any data that depends on authentication&#10;    revalidatePath('/dashboard');&#10;&#10;    return result.user;&#10;  } catch (error) {&#10;    console.error('Registration error:', error);&#10;    throw error;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to logout a user&#10; */&#10;export async function logoutUser(): Promise&lt;void&gt; {&#10;  const token = cookieStore.get('token');&#10;&#10;  if (token) {&#10;    try {&#10;      await apiRequest&lt;void&gt;('/logout', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Authorization': `Bearer ${token}`,&#10;          'Content-Type': 'application/json',&#10;        }&#10;      });&#10;    } catch (error) {&#10;      // Continue with logout even if API call fails&#10;      console.error('Logout API error:', error);&#10;    }&#10;  }&#10;&#10;  // Always delete the token cookie&#10;  cookieStore.delete('token');&#10;&#10;  // Revalidate relevant paths&#10;  revalidatePath('/', 'layout');&#10;&#10;  // Redirect to home page&#10;  redirect('/');&#10;}&#10;&#10;/**&#10; * Server-side function to get the current user&#10; */&#10;export async function getCurrentUser(): Promise&lt;User | null&gt; {&#10;  const token = cookieStore.get('token');&#10;&#10;  if (!token) {&#10;    return null;&#10;  }&#10;&#10;  try {&#10;    const user = await apiRequest&lt;User&gt;('/user', {&#10;      method: 'GET',&#10;      headers: {&#10;        'Authorization': `Bearer ${token}`,&#10;        'Content-Type': 'application/json',&#10;      }&#10;    });&#10;&#10;    return user;&#10;  } catch (error) {&#10;    // Token is invalid, clear it&#10;    cookieStore.delete('token');&#10;    return null;&#10;  }&#10;}&#10;&#10;/**&#10; * Server-side function to request password reset&#10; */&#10;export async function requestPasswordReset(data: PasswordResetRequest): Promise&lt;PasswordResetResponse&gt; {&#10;  return apiRequest&lt;PasswordResetResponse&gt;('/request-password-reset', {&#10;    method: 'POST',&#10;    headers: { 'Content-Type': 'application/json' },&#10;    body: JSON.stringify(data),&#10;  });&#10;}&#10;&#10;/**&#10; * Server-side function to reset password&#10; */&#10;export async function resetPassword(data: PasswordResetData): Promise&lt;PasswordResetResponse&gt; {&#10;  return apiRequest&lt;PasswordResetResponse&gt;('/reset-password', {&#10;    method: 'POST',&#10;    headers: { 'Content-Type': 'application/json' },&#10;    body: JSON.stringify(data),&#10;  });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/auth/[...nextauth]/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/auth/[...nextauth]/route.ts" />
              <option name="originalContent" value="import NextAuth from &quot;next-auth&quot;;&#10;import CredentialsProvider from &quot;next-auth/providers/credentials&quot;;&#10;&#10;const handler = NextAuth({&#10;  providers: [&#10;    CredentialsProvider({&#10;      name: &quot;Credentials&quot;,&#10;      credentials: {&#10;        username: { label: &quot;Username&quot;, type: &quot;text&quot; },&#10;        password: { label: &quot;Password&quot;, type: &quot;password&quot; }&#10;      },&#10;      async authorize(credentials) {&#10;        // Replace this with your own logic to validate credentials&#10;        if (credentials?.username === &quot;admin&quot; &amp;&amp; credentials?.password === &quot;admin&quot;) {&#10;          return { id: &quot;1&quot;, name: &quot;Admin User&quot;, email: &quot;admin@example.com&quot; };&#10;        }&#10;        return null;&#10;      }&#10;    })&#10;  ],&#10;  session: {&#10;    strategy: &quot;jwt&quot;&#10;  },&#10;  pages: {&#10;    signIn: &quot;/login&quot;&#10;  }&#10;});&#10;&#10;export { handler as GET, handler as POST };&#10;" />
              <option name="updatedContent" value="// This file is no longer needed. All authentication is now handled via a custom hook and axios." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/dashboard/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/dashboard/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;import { useAuth } from &quot;@/hook/useAuth&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useEffect } from &quot;react&quot;;&#10;&#10;export default function DashboardPage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.replace(&quot;/login&quot;);&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;Loading...&lt;/div&gt;;&#10;  }&#10;&#10;  if (!user) {&#10;    return (&#10;      &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Unauthorized&lt;/h1&gt;&#10;        &lt;p&gt;Please log in to access the dashboard.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dashboard&lt;/h1&gt;&#10;      &lt;p&gt;Welcome, {user.name || &quot;User&quot;}!&lt;/p&gt;&#10;      &lt;p&gt;Your email: {user.email}&lt;/p&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;import { useAuth } from &quot;@/hook/useAuth&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useEffect } from &quot;react&quot;;&#10;&#10;export default function DashboardPage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.replace(&quot;/login&quot;);&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;Loading...&lt;/div&gt;;&#10;  }&#10;&#10;  if (!user) {&#10;    return (&#10;      &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Unauthorized&lt;/h1&gt;&#10;        &lt;p&gt;Please log in to access the dashboard.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded text-center&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dashboard&lt;/h1&gt;&#10;      &lt;p&gt;Welcome, {user.name || &quot;User&quot;}!&lt;/p&gt;&#10;      &lt;p&gt;Your email: {user.email}&lt;/p&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/layout.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/layout.tsx" />
              <option name="originalContent" value="import type { Metadata } from &quot;next&quot;;&#10;import { Geist, Geist_Mono } from &quot;next/font/google&quot;;&#10;import &quot;./globals.css&quot;;&#10;import { AuthProvider } from &quot;@/context/auth-context&quot;;&#10;import { getCurrentUser } from &quot;./actions/auth&quot;;&#10;&#10;const geistSans = Geist({&#10;  variable: &quot;--font-geist-sans&quot;,&#10;  subsets: [&quot;latin&quot;],&#10;});&#10;&#10;const geistMono = Geist_Mono({&#10;  variable: &quot;--font-geist-mono&quot;,&#10;  subsets: [&quot;latin&quot;],&#10;});&#10;&#10;export const metadata: Metadata = {&#10;  title: &quot;Create Next App&quot;,&#10;  description: &quot;Generated by create next app&quot;,&#10;};&#10;&#10;export default async function RootLayout({&#10;  children,&#10;}: Readonly&lt;{&#10;  children: React.ReactNode;&#10;}&gt;) {&#10;  // Fetch the current user on the server side&#10;  const initialUser = await getCurrentUser();&#10;  &#10;  return (&#10;    &lt;html lang=&quot;en&quot;&gt;&#10;      &lt;body&#10;        className={`${geistSans.variable} ${geistMono.variable} antialiased`}&#10;        // This attribute tells React to ignore hydration mismatches on the body element only&#10;        // Perfect for the cz-shortcut-listen attribute that Chrome DevTools adds&#10;        suppressHydrationWarning&#10;      &gt;&#10;        &lt;AuthProvider initialUser={initialUser}&gt;{children}&lt;/AuthProvider&gt;&#10;      &lt;/body&gt;&#10;    &lt;/html&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="import type { Metadata } from &quot;next&quot;;&#10;import { Geist, Geist_Mono } from &quot;next/font/google&quot;;&#10;import &quot;./globals.css&quot;;&#10;import { AuthProvider } from &quot;@/context/auth-context&quot;;&#10;import { getCurrentUser } from &quot;./actions/auth&quot;;&#10;&#10;const geistSans = Geist({&#10;  variable: &quot;--font-geist-sans&quot;,&#10;  subsets: [&quot;latin&quot;],&#10;});&#10;&#10;const geistMono = Geist_Mono({&#10;  variable: &quot;--font-geist-mono&quot;,&#10;  subsets: [&quot;latin&quot;],&#10;});&#10;&#10;export const metadata: Metadata = {&#10;  title: &quot;Create Next App&quot;,&#10;  description: &quot;Generated by create next app&quot;,&#10;};&#10;&#10;export default async function RootLayout({&#10;  children,&#10;}: Readonly&lt;{&#10;  children: React.ReactNode;&#10;}&gt;) {&#10;  // Fetch the current user on the server side&#10;  const initialUser = await getCurrentUser();&#10;  &#10;  return (&#10;    &lt;html lang=&quot;en&quot;&gt;&#10;      &lt;body&#10;        className={`${geistSans.variable} ${geistMono.variable} antialiased`}&#10;        // This attribute tells React to ignore hydration mismatches on the body element only&#10;        // Perfect for the cz-shortcut-listen attribute that Chrome DevTools adds&#10;        suppressHydrationWarning&#10;      &gt;&#10;        &lt;AuthProvider initialUser={initialUser}&gt;{children}&lt;/AuthProvider&gt;&#10;      &lt;/body&gt;&#10;    &lt;/html&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/login/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/login/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import {useAuth} from &quot;@/hook/useAuth&quot;;&#10;&#10;&#10;export default function LoginPage() {&#10;  const { login, user, loading: authLoading } = useAuth();&#10;  const router = useRouter();&#10;  const [email, setEmail] = useState(&quot;&quot;);&#10;  const [password, setPassword] = useState(&quot;&quot;);&#10;  const [error, setError] = useState(&quot;&quot;);&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  // Use effect for redirecting when user state changes&#10;  useEffect(() =&gt; {&#10;    if (user &amp;&amp; !authLoading) {&#10;      router.replace(&quot;/dashboard&quot;);&#10;    }&#10;  }, [user, authLoading, router]);&#10;&#10;  const handleSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    setLoading(true);&#10;    setError(&quot;&quot;);&#10;    try {&#10;      await login(email, password);&#10;      // No need to redirect here, the useEffect will handle it&#10;    } catch (err: any) {&#10;      setError(err?.response?.data?.message || &quot;Login failed&quot;);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Login&lt;/h1&gt;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        &lt;input&#10;          type=&quot;email&quot;&#10;          placeholder=&quot;Email&quot;&#10;          value={email}&#10;          onChange={e =&gt; setEmail(e.target.value)}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;password&quot;&#10;          placeholder=&quot;Password&quot;&#10;          value={password}&#10;          onChange={e =&gt; setPassword(e.target.value)}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        {error &amp;&amp; &lt;div className=&quot;text-red-500&quot;&gt;{error}&lt;/div&gt;}&#10;        &lt;button&#10;          type=&quot;submit&quot;&#10;          className=&quot;w-full bg-blue-600 text-white p-2 rounded disabled:opacity-50&quot;&#10;          disabled={loading}&#10;        &gt;&#10;          {loading ? &quot;Logging in...&quot; : &quot;Login&quot;}&#10;        &lt;/button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import { useAuth } from &quot;@/hook/useAuth&quot;;&#10;&#10;export default function LoginPage() {&#10;  // Use enhanced auth context with loginLoading state&#10;  const { login, user, loginLoading, loading: authLoading } = useAuth();&#10;  const router = useRouter();&#10;  &#10;  // Form state&#10;  const [identifier, setIdentifier] = useState(&quot;&quot;);&#10;  const [password, setPassword] = useState(&quot;&quot;);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  // Redirect when authenticated&#10;  useEffect(() =&gt; {&#10;    if (user &amp;&amp; !authLoading) {&#10;      router.replace(&quot;/dashboard&quot;);&#10;    }&#10;  }, [user, authLoading, router]);&#10;&#10;  const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    e.preventDefault();&#10;    &#10;    // Clear previous errors&#10;    setError(null);&#10;    &#10;    try {&#10;      // Use the login method from enhanced auth context&#10;      await login(identifier, password);&#10;      // No need to redirect here, the useEffect will handle it&#10;    } catch (err: unknown) {&#10;      // Improved error handling&#10;      if (err &amp;&amp; typeof err === 'object' &amp;&amp; 'data' in err &amp;&amp; err.data) {&#10;        // Handle structured API errors&#10;        setError(err.data.message || &quot;Login failed&quot;);&#10;      } else if (err instanceof Error) {&#10;        setError(err.message || &quot;Login failed&quot;);&#10;      } else {&#10;        setError(&quot;Login failed. Please try again.&quot;);&#10;      }&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded shadow-lg&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Login to Your Account&lt;/h1&gt;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        &lt;div className=&quot;space-y-2&quot;&gt;&#10;          &lt;label htmlFor=&quot;identifier&quot; className=&quot;block text-sm font-medium&quot;&gt;&#10;            Email or Phone&#10;          &lt;/label&gt;&#10;          &lt;input&#10;            id=&quot;identifier&quot;&#10;            type=&quot;text&quot;&#10;            placeholder=&quot;Enter your email or phone&quot;&#10;            value={identifier}&#10;            onChange={e =&gt; setIdentifier(e.target.value)}&#10;            className=&quot;w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:outline-none&quot;&#10;            required&#10;            autoComplete=&quot;username&quot;&#10;            disabled={loginLoading}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;div className=&quot;space-y-2&quot;&gt;&#10;          &lt;div className=&quot;flex justify-between&quot;&gt;&#10;            &lt;label htmlFor=&quot;password&quot; className=&quot;block text-sm font-medium&quot;&gt;&#10;              Password&#10;            &lt;/label&gt;&#10;            &lt;Link &#10;              href=&quot;/reset-password&quot; &#10;              className=&quot;text-sm text-blue-600 hover:underline&quot;&#10;            &gt;&#10;              Forgot password?&#10;            &lt;/Link&gt;&#10;          &lt;/div&gt;&#10;          &lt;input&#10;            id=&quot;password&quot;&#10;            type=&quot;password&quot;&#10;            placeholder=&quot;Enter your password&quot;&#10;            value={password}&#10;            onChange={e =&gt; setPassword(e.target.value)}&#10;            className=&quot;w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:outline-none&quot;&#10;            required&#10;            autoComplete=&quot;current-password&quot;&#10;            disabled={loginLoading}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        {error &amp;&amp; (&#10;          &lt;div &#10;            className=&quot;p-3 bg-red-50 border border-red-200 text-red-700 rounded&quot; &#10;            role=&quot;alert&quot;&#10;          &gt;&#10;            {error}&#10;          &lt;/div&gt;&#10;        )}&#10;        &#10;        &lt;button&#10;          type=&quot;submit&quot;&#10;          className=&quot;w-full bg-blue-600 text-white p-2 rounded hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:outline-none transition disabled:opacity-50 disabled:bg-blue-400&quot;&#10;          disabled={loginLoading}&#10;          aria-busy={loginLoading}&#10;        &gt;&#10;          {loginLoading ? &quot;Logging in...&quot; : &quot;Login&quot;}&#10;        &lt;/button&gt;&#10;        &#10;        &lt;div className=&quot;mt-4 text-center&quot;&gt;&#10;          &lt;p className=&quot;text-sm&quot;&gt;&#10;            Don't have an account?{' '}&#10;            &lt;Link href=&quot;/register&quot; className=&quot;text-blue-600 hover:underline&quot;&gt;&#10;              Register here&#10;            &lt;/Link&gt;&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/register/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/register/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useAuth } from &quot;@/hook/useAuth&quot;;&#10;import type { RegisterData } from '@/types/auth';&#10;import { UserRole } from '@/types/auth';&#10;&#10;export default function RegisterPage() {&#10;  const { register, user, loading: authLoading } = useAuth();&#10;  const router = useRouter();&#10;  const [form, setForm] = useState&lt;RegisterData&gt;({&#10;    name: &quot;&quot;,&#10;    email: &quot;&quot;,&#10;    phone: &quot;&quot;,&#10;    password: &quot;&quot;,&#10;    password_confirmation: &quot;&quot;,&#10;    role: UserRole.USER,&#10;  });&#10;  const [error, setError] = useState(&quot;&quot;);&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  // Use effect for redirecting when user state changes&#10;  useEffect(() =&gt; {&#10;    if (user &amp;&amp; !authLoading) {&#10;      router.replace(&quot;/dashboard&quot;);&#10;    }&#10;  }, [user, authLoading, router]);&#10;&#10;  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement | HTMLSelectElement&gt;) =&gt; {&#10;    setForm({ ...form, [e.target.name]: e.target.value });&#10;  };&#10;&#10;  const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    e.preventDefault();&#10;    setLoading(true);&#10;    setError(&quot;&quot;);&#10;    try {&#10;      await register(form);&#10;      router.push(&quot;/dashboard&quot;);&#10;    } catch (err: unknown) {&#10;      if (err &amp;&amp; typeof err === 'object' &amp;&amp; 'response' in err) {&#10;        setError((err as any)?.response?.data?.message || &quot;Registration failed&quot;);&#10;      } else {&#10;        setError(&quot;Registration failed&quot;);&#10;      }&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Register&lt;/h1&gt;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          name=&quot;name&quot;&#10;          placeholder=&quot;Name&quot;&#10;          value={form.name}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;email&quot;&#10;          name=&quot;email&quot;&#10;          placeholder=&quot;Email&quot;&#10;          value={form.email}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          name=&quot;phone&quot;&#10;          placeholder=&quot;Phone&quot;&#10;          value={form.phone}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;select&#10;          name=&quot;role&quot;&#10;          value={form.role}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        &gt;&#10;          &lt;option value={UserRole.USER}&gt;User&lt;/option&gt;&#10;          &lt;option value={UserRole.ADMIN}&gt;Admin&lt;/option&gt;&#10;          &lt;option value={UserRole.SUPER_ADMIN}&gt;Super Admin&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;input&#10;          type=&quot;password&quot;&#10;          name=&quot;password&quot;&#10;          placeholder=&quot;Password&quot;&#10;          value={form.password}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;password&quot;&#10;          name=&quot;password_confirmation&quot;&#10;          placeholder=&quot;Confirm Password&quot;&#10;          value={form.password_confirmation}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        {error &amp;&amp; &lt;div className=&quot;text-red-500&quot;&gt;{error}&lt;/div&gt;}&#10;        &lt;button&#10;          type=&quot;submit&quot;&#10;          className=&quot;w-full bg-blue-600 text-white p-2 rounded disabled:opacity-50&quot;&#10;          disabled={loading}&#10;        &gt;&#10;          {loading ? &quot;Registering...&quot; : &quot;Register&quot;}&#10;        &lt;/button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useAuth } from &quot;@/hook/useAuth&quot;;&#10;import type { RegisterData } from '@/types/auth';&#10;import { UserRole } from '@/types/auth';&#10;&#10;export default function RegisterPage() {&#10;  const { register, user, loading: authLoading } = useAuth();&#10;  const router = useRouter();&#10;  const [form, setForm] = useState&lt;RegisterData&gt;({&#10;    name: &quot;&quot;,&#10;    email: &quot;&quot;,&#10;    phone: &quot;&quot;,&#10;    password: &quot;&quot;,&#10;    password_confirmation: &quot;&quot;,&#10;    role: UserRole.USER,&#10;  });&#10;  const [error, setError] = useState(&quot;&quot;);&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  // Use effect for redirecting when user state changes&#10;  useEffect(() =&gt; {&#10;    if (user &amp;&amp; !authLoading) {&#10;      router.replace(&quot;/dashboard&quot;);&#10;    }&#10;  }, [user, authLoading, router]);&#10;&#10;  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement | HTMLSelectElement&gt;) =&gt; {&#10;    setForm({ ...form, [e.target.name]: e.target.value });&#10;  };&#10;&#10;  const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    e.preventDefault();&#10;    setLoading(true);&#10;    setError(&quot;&quot;);&#10;    try {&#10;      await register(form);&#10;      router.push(&quot;/dashboard&quot;);&#10;    } catch (err: unknown) {&#10;      if (err &amp;&amp; typeof err === 'object' &amp;&amp; 'response' in err) {&#10;        setError((err as any)?.response?.data?.message || &quot;Registration failed&quot;);&#10;      } else {&#10;        setError(&quot;Registration failed&quot;);&#10;      }&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-md mx-auto mt-20 p-6 border rounded&quot;&gt;&#10;      &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Register&lt;/h1&gt;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          name=&quot;name&quot;&#10;          placeholder=&quot;Name&quot;&#10;          value={form.name}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;email&quot;&#10;          name=&quot;email&quot;&#10;          placeholder=&quot;Email&quot;&#10;          value={form.email}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          name=&quot;phone&quot;&#10;          placeholder=&quot;Phone&quot;&#10;          value={form.phone}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;select&#10;          name=&quot;role&quot;&#10;          value={form.role}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        &gt;&#10;          &lt;option value={UserRole.USER}&gt;User&lt;/option&gt;&#10;          &lt;option value={UserRole.ADMIN}&gt;Admin&lt;/option&gt;&#10;          &lt;option value={UserRole.SUPER_ADMIN}&gt;Super Admin&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;input&#10;          type=&quot;password&quot;&#10;          name=&quot;password&quot;&#10;          placeholder=&quot;Password&quot;&#10;          value={form.password}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        &lt;input&#10;          type=&quot;password&quot;&#10;          name=&quot;password_confirmation&quot;&#10;          placeholder=&quot;Confirm Password&quot;&#10;          value={form.password_confirmation}&#10;          onChange={handleChange}&#10;          className=&quot;w-full p-2 border rounded&quot;&#10;          required&#10;        /&gt;&#10;        {error &amp;&amp; &lt;div className=&quot;text-red-500&quot;&gt;{error}&lt;/div&gt;}&#10;        &lt;button&#10;          type=&quot;submit&quot;&#10;          className=&quot;w-full bg-blue-600 text-white p-2 rounded disabled:opacity-50&quot;&#10;          disabled={loading}&#10;        &gt;&#10;          {loading ? &quot;Registering...&quot; : &quot;Register&quot;}&#10;        &lt;/button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/context/auth-context.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/context/auth-context.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React, { createContext, useState, useEffect, ReactNode, useCallback, useMemo } from 'react';&#10;import type {&#10;  User,&#10;  RegisterData,&#10;  PasswordResetRequest,&#10;  PasswordResetData,&#10;  PasswordResetResponse,&#10;  AuthContextType,&#10;} from '@/types/auth';&#10;import { UserRole } from '@/types/auth';&#10;&#10;// Import server actions&#10;import {&#10;  loginUser,&#10;  registerUser,&#10;  logoutUser,&#10;  getCurrentUser,&#10;  requestPasswordReset,&#10;  resetPassword&#10;} from '@/app/actions/auth';&#10;&#10;const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);&#10;&#10;export const AuthProvider = ({ children, initialUser = null }: { children: ReactNode, initialUser?: User | null }) =&gt; {&#10;  const [user, setUser] = useState&lt;User | null&gt;(initialUser);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(!initialUser);&#10;&#10;  // Fetch the current user&#10;  const fetchUser = useCallback(async (): Promise&lt;void&gt; =&gt; {&#10;    setLoading(true);&#10;    try {&#10;      const userData = await getCurrentUser();&#10;      setUser(userData);&#10;    } catch (error) {&#10;      console.error('Error fetching user:', error);&#10;      setUser(null);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Login with identifier (email or phone) and password&#10;  const login = useCallback(async (identifier: string, password: string): Promise&lt;void&gt; =&gt; {&#10;    try {&#10;      const userData = await loginUser(identifier, password);&#10;      setUser(userData);&#10;    } catch (error) {&#10;      console.error('Login error:', error);&#10;      throw error;&#10;    }&#10;  }, []);&#10;&#10;  // Register a new user&#10;  const register = useCallback(async (data: RegisterData): Promise&lt;void&gt; =&gt; {&#10;    try {&#10;      // Ensure role is one of the valid enum values&#10;      if (!Object.values(UserRole).includes(data.role)) {&#10;        data.role = UserRole.USER; // Default to user if invalid role&#10;      }&#10;&#10;      const userData = await registerUser(data);&#10;      setUser(userData);&#10;    } catch (error) {&#10;      console.error('Registration error:', error);&#10;      throw error;&#10;    }&#10;  }, []);&#10;&#10;  // Logout the current user&#10;  const logout = useCallback(async (): Promise&lt;void&gt; =&gt; {&#10;    try {&#10;      await logoutUser();&#10;      setUser(null);&#10;    } catch (error) {&#10;      console.error('Logout error:', error);&#10;      throw error;&#10;    }&#10;  }, []);&#10;&#10;  // Request password reset (email or phone)&#10;  const handleRequestPasswordReset = useCallback(async (data: PasswordResetRequest): Promise&lt;PasswordResetResponse&gt; =&gt; {&#10;    return await requestPasswordReset(data);&#10;  }, []);&#10;&#10;  // Reset password (email+token or phone+code)&#10;  const handleResetPassword = useCallback(async (data: PasswordResetData): Promise&lt;PasswordResetResponse&gt; =&gt; {&#10;    return await resetPassword(data);&#10;  }, []);&#10;&#10;  // Fetch user on mount if not provided initially&#10;  useEffect(() =&gt; {&#10;    if (!initialUser &amp;&amp; loading) {&#10;      void fetchUser();&#10;    }&#10;  }, [fetchUser, initialUser, loading]);&#10;&#10;  // Memoize context value for performance&#10;  const value = useMemo(() =&gt; ({&#10;    user,&#10;    loading,&#10;    login,&#10;    logout,&#10;    register,&#10;    fetchUser,&#10;    requestPasswordReset: handleRequestPasswordReset,&#10;    resetPassword: handleResetPassword,&#10;  }), [user, loading, login, logout, register, fetchUser, handleRequestPasswordReset, handleResetPassword]);&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={value}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export default AuthContext;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import React, { createContext, useState, useEffect, ReactNode, useCallback, useMemo, useTransition } from 'react';&#10;import type {&#10;  User,&#10;  RegisterData,&#10;  PasswordResetRequest,&#10;  PasswordResetData,&#10;  PasswordResetResponse,&#10;  AuthContextType,&#10;} from '@/types/auth';&#10;import { UserRole } from '@/types/auth';&#10;&#10;// Import server actions&#10;import {&#10;  loginUser,&#10;  registerUser,&#10;  logoutUser,&#10;  getCurrentUser,&#10;  requestPasswordReset,&#10;  resetPassword&#10;} from '@/app/actions/auth';&#10;&#10;// Enhanced AuthContext with loading states for different operations&#10;interface EnhancedAuthContextType extends AuthContextType {&#10;  loginLoading: boolean;&#10;  registerLoading: boolean;&#10;  resetLoading: boolean;&#10;  requestResetLoading: boolean;&#10;}&#10;&#10;const AuthContext = createContext&lt;EnhancedAuthContextType | undefined&gt;(undefined);&#10;&#10;export const AuthProvider = ({ &#10;  children, &#10;  initialUser = null &#10;}: { &#10;  children: ReactNode, &#10;  initialUser?: User | null &#10;}) =&gt; {&#10;  // User state&#10;  const [user, setUser] = useState&lt;User | null&gt;(initialUser);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(!initialUser);&#10;  &#10;  // Operation-specific loading states&#10;  const [loginLoading, setLoginLoading] = useState&lt;boolean&gt;(false);&#10;  const [registerLoading, setRegisterLoading] = useState&lt;boolean&gt;(false);&#10;  const [resetLoading, setResetLoading] = useState&lt;boolean&gt;(false);&#10;  const [requestResetLoading, setRequestResetLoading] = useState&lt;boolean&gt;(false);&#10;  &#10;  // Use transition for smoother UI updates&#10;  const [isPending, startTransition] = useTransition();&#10;&#10;  // Fetch the current user&#10;  const fetchUser = useCallback(async (): Promise&lt;void&gt; =&gt; {&#10;    setLoading(true);&#10;    try {&#10;      const userData = await getCurrentUser();&#10;      startTransition(() =&gt; {&#10;        setUser(userData);&#10;      });&#10;    } catch (error) {&#10;      console.error('Error fetching user:', error);&#10;      setUser(null);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Login with identifier (email or phone) and password&#10;  const login = useCallback(async (identifier: string, password: string): Promise&lt;void&gt; =&gt; {&#10;    setLoginLoading(true);&#10;    try {&#10;      const userData = await loginUser(identifier, password);&#10;      startTransition(() =&gt; {&#10;        setUser(userData);&#10;      });&#10;    } catch (error) {&#10;      console.error('Login error:', error);&#10;      throw error;&#10;    } finally {&#10;      setLoginLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Register a new user&#10;  const register = useCallback(async (data: RegisterData): Promise&lt;void&gt; =&gt; {&#10;    setRegisterLoading(true);&#10;    try {&#10;      // Ensure role is one of the valid enum values&#10;      if (!Object.values(UserRole).includes(data.role)) {&#10;        data.role = UserRole.USER; // Default to user if invalid role&#10;      }&#10;&#10;      const userData = await registerUser(data);&#10;      startTransition(() =&gt; {&#10;        setUser(userData);&#10;      });&#10;    } catch (error) {&#10;      console.error('Registration error:', error);&#10;      throw error;&#10;    } finally {&#10;      setRegisterLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Logout the current user&#10;  const logout = useCallback(async (): Promise&lt;void&gt; =&gt; {&#10;    try {&#10;      await logoutUser();&#10;      startTransition(() =&gt; {&#10;        setUser(null);&#10;      });&#10;    } catch (error) {&#10;      console.error('Logout error:', error);&#10;      throw error;&#10;    }&#10;  }, []);&#10;&#10;  // Request password reset (email or phone)&#10;  const handleRequestPasswordReset = useCallback(async (data: PasswordResetRequest): Promise&lt;PasswordResetResponse&gt; =&gt; {&#10;    setRequestResetLoading(true);&#10;    try {&#10;      return await requestPasswordReset(data);&#10;    } finally {&#10;      setRequestResetLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Reset password (email+token or phone+code)&#10;  const handleResetPassword = useCallback(async (data: PasswordResetData): Promise&lt;PasswordResetResponse&gt; =&gt; {&#10;    setResetLoading(true);&#10;    try {&#10;      return await resetPassword(data);&#10;    } finally {&#10;      setResetLoading(false);&#10;    }&#10;  }, []);&#10;&#10;  // Fetch user on mount if not provided initially&#10;  useEffect(() =&gt; {&#10;    if (!initialUser &amp;&amp; loading) {&#10;      void fetchUser();&#10;    }&#10;  }, [fetchUser, initialUser, loading]);&#10;&#10;  // Memoize context value for performance&#10;  const value = useMemo(() =&gt; ({&#10;    user,&#10;    loading,&#10;    loginLoading,&#10;    registerLoading,&#10;    resetLoading,&#10;    requestResetLoading,&#10;    login,&#10;    logout,&#10;    register,&#10;    fetchUser,&#10;    requestPasswordReset: handleRequestPasswordReset,&#10;    resetPassword: handleResetPassword,&#10;  }), [&#10;    user, &#10;    loading, &#10;    loginLoading,&#10;    registerLoading,&#10;    resetLoading, &#10;    requestResetLoading,&#10;    login, &#10;    logout, &#10;    register, &#10;    fetchUser, &#10;    handleRequestPasswordReset, &#10;    handleResetPassword&#10;  ]);&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={value}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export default AuthContext;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hook/axiosClient.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hook/axiosClient.ts" />
              <option name="originalContent" value="import axios, { AxiosInstance } from 'axios';&#10;import Cookies from 'js-cookie';&#10;&#10;/**&#10; * axiosClient - Globally configured Axios instance&#10; * - Sets baseURL and withCredentials&#10; * - Attaches token from cookie to Authorization header&#10; * - Handles interceptors for request/response&#10; */&#10;export const axiosClient: AxiosInstance = (() =&gt; {&#10;  // If NEXT_PUBLIC_API_URL includes /api, use it as is&#10;  // Otherwise, append /api to ensure consistency with Laravel routes&#10;  let baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://127.0.0.1:8000';&#10;  if (!baseURL.endsWith('/api')) {&#10;    baseURL = `${baseURL}/api`;&#10;  }&#10;&#10;  const instance = axios.create({&#10;    baseURL,&#10;    withCredentials: false, // Change to false to avoid CORS issues with wildcard origin&#10;    headers: {&#10;      'Content-Type': 'application/json',&#10;      'Accept': 'application/json',&#10;    }&#10;  });&#10;&#10;  // Request interceptor: attach token from cookie&#10;  instance.interceptors.request.use((config) =&gt; {&#10;    const token = Cookies.get('token');&#10;    if (token &amp;&amp; config.headers) {&#10;      config.headers['Authorization'] = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  });&#10;&#10;  // Response interceptor: handle errors globally if needed&#10;  instance.interceptors.response.use(&#10;    (response) =&gt; response,&#10;    (error) =&gt; {&#10;      if (error.response?.status === 401) {&#10;        Cookies.remove('token');&#10;        if (typeof window !== 'undefined') {&#10;          window.location.href = '/login'; // Redirect to login on 401&#10;        }&#10;      }&#10;      return Promise.reject(error);&#10;    }&#10;  );&#10;&#10;  return instance;&#10;})();" />
              <option name="updatedContent" value="import axios, { AxiosInstance } from 'axios';&#10;import Cookies from 'js-cookie';&#10;&#10;/**&#10; * axiosClient - Globally configured Axios instance&#10; * - Sets baseURL and withCredentials&#10; * - Attaches token from cookie to Authorization header&#10; * - Handles interceptors for request/response&#10; */&#10;export const axiosClient: AxiosInstance = (() =&gt; {&#10;  // If NEXT_PUBLIC_API_URL includes /api, use it as is&#10;  // Otherwise, append /api to ensure consistency with Laravel routes&#10;  let baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://127.0.0.1:8000';&#10;  if (!baseURL.endsWith('/api')) {&#10;    baseURL = `${baseURL}/api`;&#10;  }&#10;&#10;  const instance = axios.create({&#10;    baseURL,&#10;    withCredentials: false, // Change to false to avoid CORS issues with wildcard origin&#10;    headers: {&#10;      'Content-Type': 'application/json',&#10;      'Accept': 'application/json',&#10;    }&#10;  });&#10;&#10;  // Request interceptor: attach token from cookie&#10;  instance.interceptors.request.use((config) =&gt; {&#10;    const token = Cookies.get('token');&#10;    if (token &amp;&amp; config.headers) {&#10;      config.headers['Authorization'] = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  });&#10;&#10;  // Response interceptor: handle errors globally if needed&#10;  instance.interceptors.response.use(&#10;    (response) =&gt; response,&#10;    (error) =&gt; {&#10;      if (error.response?.status === 401) {&#10;        Cookies.remove('token');&#10;        if (typeof window !== 'undefined') {&#10;          window.location.href = '/login'; // Redirect to login on 401&#10;        }&#10;      }&#10;      return Promise.reject(error);&#10;    }&#10;  );&#10;&#10;  return instance;&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hook/useAuth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hook/useAuth.ts" />
              <option name="updatedContent" value="import { useContext } from 'react';&#10;import AuthContext from '../context/auth-context';&#10;import type { AuthContextType } from '@/types/auth';&#10;&#10;/**&#10; * Enhanced auth hook with proper typing and error handling&#10; * @returns The auth context with all authentication methods and states&#10; */&#10;export const useAuth = () =&gt; {&#10;  const context = useContext(AuthContext);&#10;  &#10;  if (!context) {&#10;    throw new Error('useAuth must be used within AuthProvider');&#10;  }&#10;  &#10;  return context as AuthContextType &amp; {&#10;    loginLoading: boolean;&#10;    registerLoading: boolean;&#10;    resetLoading: boolean;&#10;    requestResetLoading: boolean;&#10;  };&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/auth-context.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/auth-context.tsx" />
              <option name="originalContent" value="import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';&#10;import axios from 'axios';&#10;import Cookies from 'js-cookie';&#10;&#10;interface User {&#10;  id: number;&#10;  name: string;&#10;  email: string;&#10;  // Add more fields as needed&#10;}&#10;&#10;interface AuthContextType {&#10;  user: User | null;&#10;  loading: boolean;&#10;  login: (email: string, password: string) =&gt; Promise&lt;void&gt;;&#10;  logout: () =&gt; Promise&lt;void&gt;;&#10;  register: (data: { name: string; email: string; password: string; password_confirmation: string }) =&gt; Promise&lt;void&gt;;&#10;  fetchUser: () =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;interface LoginResponse {&#10;  token: string;&#10;}&#10;&#10;const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);&#10;&#10;export const AuthProvider = ({ children }: { children: ReactNode }) =&gt; {&#10;  const [user, setUser] = useState&lt;User | null&gt;(null);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(true);&#10;&#10;  // Set axios defaults&#10;  axios.defaults.baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';&#10;  axios.defaults.withCredentials = true;&#10;&#10;  // Attach token from cookie if exists&#10;  axios.interceptors.request.use((config) =&gt; {&#10;    const token = Cookies.get('token');&#10;    if (token &amp;&amp; config.headers) {&#10;      config.headers['Authorization'] = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  });&#10;&#10;  const fetchUser = async (): Promise&lt;void&gt; =&gt; {&#10;    setLoading(true);&#10;    try {&#10;      const { data } = await axios.get&lt;User&gt;('/api/user');&#10;      setUser(data);&#10;    } catch {&#10;      setUser(null);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const login = async (email: string, password: string): Promise&lt;void&gt; =&gt; {&#10;    await axios.get('/sanctum/csrf-cookie');&#10;    const { data } = await axios.post&lt;LoginResponse&gt;('/login', { email, password });&#10;    Cookies.set('token', data.token);&#10;    await fetchUser();&#10;  };&#10;&#10;  const register = async (data: { name: string; email: string; password: string; password_confirmation: string }): Promise&lt;void&gt; =&gt; {&#10;    await axios.get('/sanctum/csrf-cookie');&#10;    await axios.post('/register', data);&#10;    await login(data.email, data.password);&#10;  };&#10;&#10;  const logout = async (): Promise&lt;void&gt; =&gt; {&#10;    await axios.post('/logout');&#10;    Cookies.remove('token');&#10;    setUser(null);&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    fetchUser();&#10;  }, []);&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={{ user, loading, login, logout, register, fetchUser }}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export const useAuth = () =&gt; {&#10;  const context = useContext(AuthContext);&#10;  if (!context) throw new Error('useAuth must be used within AuthProvider');&#10;  return context;&#10;};" />
              <option name="updatedContent" value="import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';&#10;import Cookies from 'js-cookie';&#10;import { axiosClient } from './use-api';&#10;&#10;interface User {&#10;  id: number;&#10;  name: string;&#10;  email: string;&#10;  // Add more fields as needed&#10;}&#10;&#10;interface AuthContextType {&#10;  user: User | null;&#10;  loading: boolean;&#10;  login: (email: string, password: string) =&gt; Promise&lt;void&gt;;&#10;  logout: () =&gt; Promise&lt;void&gt;;&#10;  register: (data: { name: string; email: string; password: string; password_confirmation: string }) =&gt; Promise&lt;void&gt;;&#10;  fetchUser: () =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;interface LoginResponse {&#10;  token: string;&#10;}&#10;&#10;const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);&#10;&#10;export const AuthProvider = ({ children }: { children: ReactNode }) =&gt; {&#10;  const [user, setUser] = useState&lt;User | null&gt;(null);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(true);&#10;&#10;  const fetchUser = async (): Promise&lt;void&gt; =&gt; {&#10;    setLoading(true);&#10;    try {&#10;      const { data } = await axiosClient.get&lt;User&gt;('/api/user');&#10;      setUser(data);&#10;    } catch {&#10;      setUser(null);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const login = async (email: string, password: string): Promise&lt;void&gt; =&gt; {&#10;    await axiosClient.get('/sanctum/csrf-cookie');&#10;    const { data } = await axiosClient.post&lt;LoginResponse&gt;('/login', { email, password });&#10;    Cookies.set('token', data.token);&#10;    await fetchUser();&#10;  };&#10;&#10;  const register = async (data: { name: string; email: string; password: string; password_confirmation: string }): Promise&lt;void&gt; =&gt; {&#10;    await axiosClient.get('/sanctum/csrf-cookie');&#10;    await axiosClient.post('/register', data);&#10;    await login(data.email, data.password);&#10;  };&#10;&#10;  const logout = async (): Promise&lt;void&gt; =&gt; {&#10;    await axiosClient.post('/logout');&#10;    Cookies.remove('token');&#10;    setUser(null);&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    fetchUser();&#10;  }, []);&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={{ user, loading, login, logout, register, fetchUser }}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export const useAuth = () =&gt; {&#10;  const context = useContext(AuthContext);&#10;  if (!context) throw new Error('useAuth must be used within AuthProvider');&#10;  return context;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/use-api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/use-api.ts" />
              <option name="originalContent" value="import { useMemo } from 'react';&#10;import axios, { AxiosInstance } from 'axios';&#10;import Cookies from 'js-cookie';&#10;&#10;/**&#10; * axiosClient - Globally configured Axios instance&#10; * - Sets baseURL and withCredentials&#10; * - Attaches token from cookie to Authorization header&#10; * - Handles interceptors for request/response&#10; */&#10;export const axiosClient: AxiosInstance = (() =&gt; {&#10;  const instance = axios.create({&#10;    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',&#10;    withCredentials: true,&#10;  });&#10;&#10;  // Request interceptor: attach token from cookie&#10;  instance.interceptors.request.use((config) =&gt; {&#10;    const token = Cookies.get('token');&#10;    if (token &amp;&amp; config.headers) {&#10;      config.headers['Authorization'] = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  });&#10;&#10;  // Response interceptor: handle errors globally if needed&#10;  instance.interceptors.response.use(&#10;    (response) =&gt; response,&#10;    (error) =&gt; {&#10;      // You can handle global errors here (e.g., logout on 401)&#10;      return Promise.reject(error);&#10;    }&#10;  );&#10;&#10;  return instance;&#10;})();" />
              <option name="updatedContent" value="import { useMemo } from 'react';&#10;import axios, { AxiosInstance } from 'axios';&#10;import Cookies from 'js-cookie';&#10;&#10;/**&#10; * axiosClient - Globally configured Axios instance&#10; * - Sets baseURL and withCredentials&#10; * - Attaches token from cookie to Authorization header&#10; * - Handles interceptors for request/response&#10; */&#10;export const axiosClient: AxiosInstance = (() =&gt; {&#10;  const instance = axios.create({&#10;    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',&#10;    withCredentials: true,&#10;  });&#10;&#10;  // Request interceptor: attach token from cookie&#10;  instance.interceptors.request.use((config) =&gt; {&#10;    const token = Cookies.get('token');&#10;    if (token &amp;&amp; config.headers) {&#10;      config.headers['Authorization'] = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  });&#10;&#10;  // Response interceptor: handle errors globally if needed&#10;  instance.interceptors.response.use(&#10;    (response) =&gt; response,&#10;    (error) =&gt; {&#10;      // You can handle global errors here (e.g., logout on 401)&#10;      return Promise.reject(error);&#10;    }&#10;  );&#10;&#10;  return instance;&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/middleware.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/middleware.ts" />
              <option name="originalContent" value="import { NextResponse } from 'next/server';&#10;import type { NextRequest } from 'next/server';&#10;&#10;// Paths that don't require authentication&#10;const publicPaths = ['/', '/login', '/register', '/reset-password'];&#10;&#10;export function middleware(request: NextRequest) {&#10;  const token = request.cookies.get('token')?.value;&#10;  const { pathname } = request.nextUrl;&#10;&#10;  // Check if the path is public&#10;  const isPublicPath = publicPaths.some(path =&gt;&#10;    pathname === path || pathname.startsWith(`${path}/`)&#10;  );&#10;&#10;  // Redirect to login if accessing protected route without token&#10;  if (!token &amp;&amp; !isPublicPath) {&#10;    const url = request.nextUrl.clone();&#10;    url.pathname = '/login';&#10;    url.searchParams.set('from', pathname);&#10;    return NextResponse.redirect(url);&#10;  }&#10;&#10;  // Redirect to dashboard if accessing auth pages with valid token&#10;  if (token &amp;&amp; (pathname === '/login' || pathname === '/register')) {&#10;    const url = request.nextUrl.clone();&#10;    url.pathname = '/dashboard';&#10;    return NextResponse.redirect(url);&#10;  }&#10;&#10;  return NextResponse.next();&#10;}&#10;&#10;// Configure which routes use this middleware&#10;export const config = {&#10;  matcher: [&#10;    // Apply to all routes except for static files, api routes, and _next&#10;    '/((?!api|_next/static|_next/image|favicon.ico).*)',&#10;  ],&#10;};" />
              <option name="updatedContent" value="import { NextResponse } from 'next/server';&#10;import type { NextRequest } from 'next/server';&#10;&#10;// Paths that don't require authentication&#10;const publicPaths = ['/', '/login', '/register', '/reset-password'];&#10;&#10;export default function middleware(request: NextRequest) {&#10;  // Get the pathname from the request&#10;  const pathname = request.nextUrl.pathname;&#10;&#10;  // Get auth token from cookies&#10;  const token = request.cookies.get('token')?.value;&#10;&#10;  // Check if the path is public&#10;  const isPublicPath = publicPaths.some(&#10;    path =&gt; pathname === path || pathname.startsWith(`${path}/`)&#10;  );&#10;&#10;  // Redirect to login if accessing protected route without token&#10;  if (!token &amp;&amp; !isPublicPath) {&#10;    return NextResponse.redirect(new URL('/login', request.url));&#10;  }&#10;&#10;  // Redirect to dashboard if accessing auth pages with valid token&#10;  if (token &amp;&amp; (pathname === '/login' || pathname === '/register')) {&#10;    return NextResponse.redirect(new URL('/dashboard', request.url));&#10;  }&#10;&#10;  return NextResponse.next();&#10;}&#10;&#10;// Configure which routes use this middleware&#10;export const config = {&#10;  matcher: [&#10;    /*&#10;     * Match all request paths except for:&#10;     * - api routes (/api/*)&#10;     * - _next (Next.js internals)&#10;     * - Static files like favicon.ico, etc.&#10;     */&#10;    '/((?!api|_next/static|_next/image|favicon.ico).*)',&#10;  ],&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/types/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/types/auth.ts" />
              <option name="originalContent" value="// Auth-related types for context, hooks, and API&#10;&#10;export enum UserRole {&#10;  USER = 'user',&#10;  ADMIN = 'admin',&#10;  SUPER_ADMIN = 'super-admin'&#10;}&#10;&#10;export interface User {&#10;  id: number;&#10;  name: string;&#10;  email?: string;&#10;  phone?: string;&#10;  role: UserRole;&#10;}&#10;&#10;export interface RegisterData {&#10;  name: string;&#10;  email: string;  // Changed from email?: string to make it required&#10;  phone: string;  // Changed from phone?: string to make it required&#10;  password: string;&#10;  password_confirmation: string;&#10;  role: UserRole;&#10;}&#10;&#10;export interface PasswordResetRequest {&#10;  email?: string;&#10;  phone?: string;&#10;}&#10;&#10;export interface PasswordResetData {&#10;  email?: string;&#10;  phone?: string;&#10;  token?: string;&#10;  code?: string;&#10;  password: string;&#10;  password_confirmation: string;&#10;}&#10;&#10;export interface PasswordResetResponse {&#10;  message: string;&#10;  code?: string;&#10;}&#10;&#10;export interface LoginResponse {&#10;  token: string;&#10;  user: User;&#10;}&#10;&#10;export interface AuthContextType {&#10;  user: User | null;&#10;  loading: boolean;&#10;  login: (identifier: string, password: string) =&gt; Promise&lt;void&gt;;&#10;  logout: () =&gt; Promise&lt;void&gt;;&#10;  register: (data: RegisterData) =&gt; Promise&lt;void&gt;;&#10;  fetchUser: () =&gt; Promise&lt;void&gt;;&#10;  requestPasswordReset: (data: PasswordResetRequest) =&gt; Promise&lt;PasswordResetResponse&gt;;&#10;  resetPassword: (data: PasswordResetData) =&gt; Promise&lt;PasswordResetResponse&gt;;&#10;}" />
              <option name="updatedContent" value="// Auth-related types for context, hooks, and API&#10;&#10;export enum UserRole {&#10;  USER = 'user',&#10;  ADMIN = 'admin',&#10;  SUPER_ADMIN = 'super-admin'&#10;}&#10;&#10;export interface User {&#10;  id: number;&#10;  name: string;&#10;  email?: string;&#10;  phone?: string;&#10;  role: UserRole;&#10;}&#10;&#10;export interface RegisterData {&#10;  name: string;&#10;  email: string;  // Changed from email?: string to make it required&#10;  phone: string;  // Changed from phone?: string to make it required&#10;  password: string;&#10;  password_confirmation: string;&#10;  role: UserRole;&#10;}&#10;&#10;export interface PasswordResetRequest {&#10;  email?: string;&#10;  phone?: string;&#10;}&#10;&#10;export interface PasswordResetData {&#10;  email?: string;&#10;  phone?: string;&#10;  token?: string;&#10;  code?: string;&#10;  password: string;&#10;  password_confirmation: string;&#10;}&#10;&#10;export interface PasswordResetResponse {&#10;  message: string;&#10;  code?: string;&#10;}&#10;&#10;export interface LoginResponse {&#10;  token: string;&#10;  user: User;&#10;}&#10;&#10;export interface AuthContextType {&#10;  user: User | null;&#10;  loading: boolean;&#10;  login: (identifier: string, password: string) =&gt; Promise&lt;void&gt;;&#10;  logout: () =&gt; Promise&lt;void&gt;;&#10;  register: (data: RegisterData) =&gt; Promise&lt;void&gt;;&#10;  fetchUser: () =&gt; Promise&lt;void&gt;;&#10;  requestPasswordReset: (data: PasswordResetRequest) =&gt; Promise&lt;PasswordResetResponse&gt;;&#10;  resetPassword: (data: PasswordResetData) =&gt; Promise&lt;PasswordResetResponse&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/types/js-cookie.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/types/js-cookie.d.ts" />
              <option name="updatedContent" value="// Type definitions for js-cookie&#10;// Project: https://github.com/js-cookie/js-cookie&#10;// Definitions by: Andi Dittrich &lt;https://github.com/AndiDittrich&gt;&#10;//                 Rafael Siegelmann &lt;https://github.com/rafaelsg&gt;&#10;//                 BendingBender &lt;https://github.com/BendingBender&gt;&#10;//                 Leonard Thieu &lt;https://github.com/leonard-thieu&gt;&#10;// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped&#10;&#10;export interface CookieAttributes {&#10;    expires?: number | Date;&#10;    path?: string;&#10;    domain?: string;&#10;    secure?: boolean;&#10;    sameSite?: 'strict' | 'lax' | 'none';&#10;}&#10;&#10;export interface CookiesStatic&lt;T = undefined&gt; {&#10;    get(name: string): string | undefined;&#10;    get(): { [key: string]: string };&#10;    set(name: string, value: string, options?: CookieAttributes): void;&#10;    remove(name: string, options?: CookieAttributes): void;&#10;}&#10;&#10;declare const Cookies: CookiesStatic;&#10;export default Cookies;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>